<html style=font-family:arial><head><title>Morph</title></head><body><h1>Module: Morph</h1><div> <b>Morph</b> performs low-level morphological operations on binary or grayscale images <hr><p>This module performs a series of morphological operations on a binary image or grayscale image, resulting in an image of the same type. Many require some image processing knowledge to understand how best to use these morphological filters in order to achieve the desired result. Note that the algorithms minimize the interference of masked pixels; for instance, the dilate operation will only consider unmasked pixels in the neighborhood of a pixel when determining the maximum within that neighborhood. <br> <br> The following operations are available:<br><br> <table border="1"> <tr><td><b>Operation</b></td><td><b>Description</b></td> <td><b>Input image type allowed</b></td></tr> <tr> <td><i>Bothat</i></td> <td>Bottom-hat filter: A bottom-hat filter enhances black spots in a white background.  It subtracts the morphological <i>Close</i> of the image from the image. See below for a description of <i>Close</i>.</td> <td>Binary, grayscale</td> </tr> <tr><td><i>Branchpoints</i></td> <td>Removes all pixels except those that are the branchpoints of a skeleton. This operation should be applied to an image after skeletonizing. It leaves only those pixels that are at the intersection of branches.<br> <table> <tr><td><table border="1"> <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>   <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>       <tr><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>     </table></td> <td>&rarr;</td> <td><table border="1"> <tr><td>?</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>   <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>       <tr><td>?</td><td>0</td><td>0</td><td>0</td><td>?</td></tr>     </table></td></tr> </table></td> <td>Binary </td></tr> <tr> <td><i>Bridge</i></td> <td>Sets a pixel to 1 if it has two non-zero neighbors that are on opposite  sides of this pixel:<br> <table>  <tr> <td><table border="1"> <tr><td>1</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>0</td><td>0</td></tr>   <tr><td>0</td><td>0</td><td>1</td></tr>       </table></td> <td>&rarr;</td> <td><table border="1"> <tr><td>1</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>1</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>1</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Clean</i></td> <td>Removes isolated pixels:<br> <table>  <tr> <td><table border=1> <tr><td>0</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>0</td><td>0</td></tr>   <tr><td>0</td><td>0</td><td>0</td></tr>       </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>1</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>0</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Close</i></td> <td>Performs a dilation followed by an erosion. The effect is to fill holes and join nearby objects. </td> <td>Binary, grayscale</td> </tr> <tr> <td><i>Convex hull</i></td> <td>Finds the convex hull of a binary image. The convex hull is the smallest convex polygon that fits around all foreground pixels of the image: it is the shape that a rubber band would take if stretched around the foreground pixels. The convex hull can be used to regularize the boundary of a large, single object in an image, for instance, the edge of a well.</td> <td>Binary</td></tr> <tr> <td><i>Diag</i></td> <td>Fills in pixels whose neighbors are diagnonally connected to 4-connect  pixels that are 8-connected:<br> <table> <tr> <td><table border=1> <tr><td>0</td><td>1</td></tr> <tr><td>1</td><td>0</td></tr> </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>1</td><td>1</td></tr> <tr><td>1</td><td>1</td></tr> </table></td> <td>&nbsp;,&nbsp;</td> <td><table border=1> <tr><td>0</td><td>1</td></tr> <tr><td>1</td><td>1</td></tr> </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>1</td><td>1</td></tr> <tr><td>1</td><td>1</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Dilate</i></td> <td>For binary, replaces any 0 pixel by 1 if any of its neighbors is 1.  For grayscale, each pixel is replaced by the maximum of its neighbors and itself.</td> <td>Binary, grayscale</td> </tr> <tr> <td><i>Distance</i></td> <td>Computes the distance transform of a binary image. The distance of each foreground pixel is computed to the nearest background pixel. The resulting image is then scaled so that the largest distance is 1.</td> <td>Binary</td> </tr> <tr>         <td><i>Erode</i></td> <td>For binary, replaces any 1 pixel by 0 if any of its neighbors is 0.  For grayscale, each pixel is replaced by the minimum of its neighbors and itself.</td> <td>Binary, grayscale</td> </tr> <tr> <td><i>Endpoints</i></td> <td>Removes all pixels except the ones that are at the end of a skeleton:<br> <table> <tr> <td><table border=1> <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>     <tr><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td></tr>   <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>       <tr><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr>     </table></td> <td>&rarr;</td> <td><table border="1"> <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>     <tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>     <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>   <tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr>       <tr><td>0</td><td>?</td><td>0</td><td>0</td><td>?</td></tr>     </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Fill</i></td> <td>Sets a pixel to 1 if all of its neighbors are 1:<br> <table> <tr> <td><table border=1> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>1</td><td>0</td><td>1</td></tr> <tr><td>1</td><td>1</td><td>1</td></tr> </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>1</td><td>1</td><td>1</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Fill small holes</i></td> <td>Sets background pixels surrounded by foreground pixels to 1.<br> This operation fills in small holes in a binary image. You can set the maximum area of a hole in order to restrict the operation to holes of a given size or smaller. </td> <td>Binary</td> </tr> <tr> <td><i>Hbreak</i></td> <td>Removes pixels that form vertical bridges between horizontal lines:<br> <table> <tr> <td><table border=1> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>0</td><td>1</td><td>0</td></tr> <tr><td>1</td><td>1</td><td>1</td></tr> </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>0</td><td>0</td><td>0</td></tr> <tr><td>1</td><td>1</td><td>1</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Invert</i></td> <td>For a binary image, transforms background to foreground and vice-versa. For a grayscale image, invert its intensity. </td><td>Binary, Grayscale</td> </tr> <tr> <td><i>Majority</i></td> <td>Each pixel takes on the value of the majority that surround it  (keep pixel value to break ties):<br> <table> <tr> <td><table border=1> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>1</td><td>0</td><td>1</td></tr> <tr><td>0</td><td>0</td><td>0</td></tr> </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>0</td><td>0</td><td>0</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Life</i></td><td>Applies the interaction rules from the  <a href="http://en.wikipedia.org/wiki/Conway%27s_Game_of_Life">Game of Life</a>,  an example of a cellular automaton.</td> <td>Binary</td> </tr> <tr> <td><i>Open</i></td><td>Performs an erosion followed by a dilation. The effect is to break bridges between objects and remove single pixels.</td> <td>Binary, grayscale</td> </tr> <tr> <td><i>Remove</i></td> <td>Removes pixels that are otherwise surrounded by others (4 connected).  The effect is to leave the perimeter of a solid object:<br> <table> <tr> <td><table border=1> <tr><td>0</td><td>1</td><td>0</td></tr> <tr><td>1</td><td>1</td><td>1</td></tr> <tr><td>0</td><td>1</td><td>0</td></tr> </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>0</td><td>1</td><td>0</td></tr> <tr><td>1</td><td>0</td><td>1</td></tr> <tr><td>0</td><td>1</td><td>0</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Shrink</i></td> <td>Performs a thinning operation that erodes unless that operation would change the image's Euler number. This means that blobs are reduced to single  points and blobs with holes are reduced to rings if shrunken indefinitely.</td> <td>Binary</td> </tr> <tr> <td><i>Skel</i></td> <td>Performs a skeletonizing operation (medial axis transform). Preserves  the points at the edges of objects but erodes everything else to lines that connect those edges. See <a href="http://homepages.inf.ed.ac.uk/rbf/HIPR2/skeleton.htm">here</a> for a description.</td> <td>Binary</td> </tr> <tr> <td><i>SkelPE</i></td> <td>Performs a skeletonizing operation using the metric, PE * D to control the erosion order. PE is the Poisson Equation (see Gorelick,  "Shape representation and classification using the Poisson Equation",  IEEE Transactions on Pattern Analysis and Machine Intelligence V28, # 12, 2006) evaluated within the foreground with the boundary condition that the background is zero. D is the distance transform (distance of a pixel to the nearest edge). The resulting skeleton has fewer spurs but some bit of erosion at the endpoints  in the binary image.</td> <td>Binary</td> </tr> <tr> <td><i>Spur</i></td> <td>Removes spur pixels, i.e., pixels that have exactly one 8-connected neighbor. This operation essentially removes the endpoints of lines.<br> <table> <tr> <td><table border=1> <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>1</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>1</td><td>0</td></tr> <tr><td>1</td><td>1</td><td>1</td><td>1</td></tr> </table></td> <td>&rarr;</td> <td><table border=1> <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr> <tr><td>0</td><td>0</td><td>1</td><td>0</td></tr> <tr><td>1</td><td>1</td><td>1</td><td>1</td></tr> </table></td> </tr> </table> </td> <td>Binary</td> </tr> <tr> <td><i>Thicken</i></td> <td>Dilates the exteriors of objects where that dilation does not 8-connect the object with another. The image is labeled and the labeled objects are filled.  Unlabeled points adjacent to uniquely labeled points change from background to foreground.</td> <td>Binary</td> </tr> <tr> <td><i>Thin</i></td> <td>Thin lines preserving the Euler number using the thinning algorithm # 1 described in  Guo, "Parallel Thinning with Two Subiteration Algorithms", <i>Communications of the ACM,</i> Vol 32 #3,  page 359. The result generally preserves the lines in an image while eroding their thickness.</td> <td>Binary</td> </tr> <tr> <td><i>Tophat</i></td> <td>Subtracts the morphological opening of the image from the image. This enhances white spots  in a black background.</td> <td>Binary, grayscale</td> </tr> <tr>   <td><i>Vbreak</i></td>   <td>Removes pixels that form horizontal bridges between vertical lines:<br>     <table>       <tr>         <td><table border=1>           <tr><td>1</td><td>0</td><td>1</td></tr>           <tr><td>1</td><td>1</td><td>1</td></tr>           <tr><td>1</td><td>0</td><td>1</td></tr>         </table></td>         <td>&rarr;</td>         <td><table border=1>           <tr><td>1</td><td>0</td><td>1</td></tr>           <tr><td>1</td><td>0</td><td>1</td></tr>           <tr><td>1</td><td>0</td><td>1</td></tr>         </table></td>       </tr>     </table></td>   <td>Binary</td> </tr> </table> </div><div><h2>Settings:</h2><h4>Select the input image</h4><div>
            Select the image that you want to perform a morphological operation on.
            A grayscale image can be
            converted to binary using the <b>ApplyThreshold</b> module. Objects can be
            converted to binary using the <b>ConvertToImage</b> module.</div><h4>Name the output image</h4><div>
            Enter the name for the output image It will be of the same type as the
            input image.</div><h4>Select the operation to perform</h4><div>
            Choose one of the operations described in this module's help.</div><h4>Number of times to repeat operation</h4><div>
            This setting controls the number of times that the same operation is applied
            successively to the image.
            <ul>
            <li><i>Once:</i> Perform the operation once on the image.</li>
            <li><i>Forever:</i> Perform the operation on the image until successive
            iterations yield the same image.</li>
            <li><i>Custom:</i> Perform the operation a custom number of times.</li>
            </ul></div><h4>Repetition number</h4><div><i>(Used only if Custom selected)</i><br>Enter the number of times to repeat the operation</div><h4>Scale</h4><div>
            Morphological open, close, erode and dialate are performed
            with structuring elements which determine the diameter of the
            circle enclosing the pixels to consider when applying the operation.
            This setting controls the diameter of the structuring element.</div><h4>Structuring element</h4><div>
            <i>(Used only for bothat, close, dilate, erode, open and tophat)</i><br>
            The structuring element controls which neighboring pixels participate 
            in the operation. For instance, for the erode operation, all 
            pixels in the neighborhood of the pixel must be in the foreground for 
            the pixel to be in the foreground in the output image. If a circular
            structuring element is used, then a pixel will be in the foreground
            only if all neighborhood pixels within a circle surrounding the
            pixel are in the foreground in the input image.
            
            <p>The structuring elements are:<br>
            <ul>
            <li><i>Disk</i>: A disk centered on the pixel. The scale
            setting determines the circle's diameter and all pixels that are
            at or closer than that diameter will be in the neighborhood.</li>
            <li><i>Custom</i>: A structuring element which lets
            the user choose the exact neighborhood pixels to use.</li>
            <li><i>Diamond</i>: A diamond centered on the pixel. The 
            scale setting determines the distance between the top and bottom
            and left and right corners of the diamond.</li>
            <li><i>Line</i>: A line centered on the pixel. The line
            has two settings. The angle setting gives the rotation of the line
            in the counter-clockwise direction in degrees, with a horizontal
            line having an angle of zero. The length of the line is determined
            by the scale setting - only pixels at or closer than 1/2 of the
            scale are included in the neighborhood. The line is drawn using
            the <a href="https://doi.org/10.1147%2Fsj.41.0025">
            Bresenham algorithm</a>.</li>
            <li><i>Octagon</i>: An octagon centered on the pixel. The
            octagon is inscribed inside a square. The scale setting controls
            the length of the square's side. The scale is rounded to the nearest
            integer in the series, n * 6 + 1 so a perfect octagon can be drawn.</li>
            <li><i>Pair</i>: The neighborhood of the pixel is
            composed of the pixel itself and the pixel at the x and y offsets
            given by the settings.</li>
            <li><i>Periodic line</i>: The points along a line described
            by an offset, centered on the pixel. The periodic line has three 
            settings. The neighborhood pixels are all within a circle whose
            diameter is the scale setting. Within the circle, pixels are
            chosen at N times the x and y offset from the center for positive
            and negative values of N.</li>
            <li><i>Rectangle</i>: A rectangle centered on the pixel.
            The rectangle's height and width are given by two settings.</li>
            <li><i>Square</i>: a square centered on the pixel. The
            scale setting determines the length of the square's side.</li>
            </ul></p></div><h4>X offset</h4><div>
            <i>(Used only for the Pair and Periodic line
            settings)</i>. The X offset to the first neighborhood pixel in
            the structuring element.
            </div><h4>Y offset</h4><div>
            <i>(Used only for the Pair and Periodic line
            structuring elements)</i>. The Y offset to the first neighborhood
            pixel in the structuring element.
            </div><h4>Angle</h4><div>
            <i>(Used only for the Line structuring element).</i>
            The angle, in degrees counter-clockwise from the horizontal,
            of the line.
            </div><h4>Width</h4><div>
            <i>(Used only for the Rectangle structuring element).</i>
            The width of the rectangle in pixels.
            </div><h4>Height</h4><div>
            <i>(Used only for the Rectangle structuring element).</i>
            The height of the rectangle in pixels.
            </div><h4>Custom</h4><div>
            <i>(Used only for the Custom structuring element).</i>
            This control lets you specify a custom structuring element.
            </div><h4>Rescale values from 0 to 1?</h4><div>
            <i>(Used only for the distance operation).</i>
            <p>Select <i>Yes</i> to rescale the transformed values to lie between 0 and 1.
            This is the option to use if the distance transformed image is to be used
            for thresholding by an <b>Identify</b> module or the like, which assumes
            a 0-1 scaling.</p>
            <p>Select <i>No</i> to leave the values in absolute pixel units.
            This useful in cases where the actual pixel distances are to be used
            downstream as input for a measurement module.</p>
            </div></div></body></html>